% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model.R
\name{nll_fun}
\alias{nll_fun}
\title{Negative log-likelihood (and simulator) for the Tiny Assessment Model}
\usage{
nll_fun(par, simulate = FALSE)
}
\arguments{
\item{par}{Named list of parameters in the format produced by
\code{\link[=make_par]{make_par()}}. This includes scalars (e.g., \verb{log_sd_*}), vectors
(e.g., \code{log_r}, \code{log_q}), and matrices (e.g., \code{log_f}, \code{log_n}, \code{log_m}).}

\item{simulate}{Logical. If \code{FALSE}, return the JNLL. If \code{TRUE}, simulate
random effects and observations and return them (see \strong{Value}).}
}
\value{
If \code{simulate = FALSE}: a single numeric JNLL value.
If \code{simulate = TRUE}: a list with elements
\itemize{
\item \code{log_f}, \code{log_r} — always returned;
\item \code{log_n} — if \code{N_settings$process != "off"};
\item \code{log_m} — if \code{M_settings$process != "off"};
\item \code{log_obs} — simulated observations (NAs restored where input was missing);
\item \code{missing} — the simulated values at missing-observation positions.
}
}
\description{
Core objective function for TAM. When \code{simulate = FALSE} (default) it
returns the joint negative log-likelihood (JNLL) of the state–space model
given parameters in \code{par} and data/flags in the captured \code{dat} list.
When \code{simulate = TRUE}, it draws the model’s random effects and observations
from the assumed distributions and returns a list of simulated objects
(see \strong{Value}).
}
\details{
The model follows a standard age–structured state–space formulation:
\itemize{
\item \strong{Recruitment:} log-recruits \code{log_r[y]} evolve as a random walk:
\deqn{\Delta \log R_y \sim \mathcal{N}(0,\sigma_R^2).}
If \code{N_settings$init_N0} is \code{TRUE}, the initial recruit level
is constrained by \eqn{\log R_1 \sim \mathcal{N}(\log R_0,\sigma_R^2)}.
\item \strong{Numbers-at-age:} forward cohort dynamics with plus-group:
\deqn{\log N_{y,a} = \log N_{y-1,a-1} - Z_{y-1,a-1},}
with \eqn{Z_{y,a} = F_{y,a} + M_{y,a}} and the plus-group equation applied
at the terminal age. If \code{N_settings$process != "off"}, residuals
\eqn{\eta^N_{y,a} = \log N_{y,a} - \widehat{\log N}_{y,a}}
are penalized by \code{dprocess_2d()} according to the chosen process.
\item \strong{Fishing mortality:} \eqn{\log F_{y,a}} is decomposed as
\deqn{\log F_{y,a} = \mu^F_{y,a} + \eta^F_{y,a},}
where the optional fixed-effects surface \eqn{\mu^F} comes from
\code{F_modmat \%*\% log_mu_f} (if \code{F_settings$mu_form} is provided), and the
process deviations \eqn{\eta^F} are penalized by \code{dprocess_2d()} using
\code{F_settings$process} and \code{logit_phi_f} (AR1) or a RW/IID penalty.
\item \strong{Natural mortality:} \eqn{\log M_{y,a}} is
\deqn{\log M_{y,a} = \log \mu^M_{y,a} + \eta^M_{y,a},}
where \eqn{\log \mu^M = \texttt{log\_mu\_assumed\_m} + M\_modmat \,\texttt{log\_mu\_m}}.
If \code{M_settings$process != "off"}, the deviations \eqn{\eta^M} are penalized
by \code{dprocess_2d()} and may be grouped by age via \code{M_settings$age_blocks}.
\item \strong{Observations:} catch-at-age and index-at-age on the log scale:
\deqn{\log C_{y,a} \sim \mathcal{N}\!\left(\log\!\left[N_{y,a}
      \frac{F_{y,a}}{Z_{y,a}} \left(1-e^{-Z_{y,a}}\right)\right], \sigma^2_{\text{obs}}\right),}
\deqn{\log I_{y,a} \sim \mathcal{N}\!\left(\log q_{a} + \log N_{y,a} - Z_{y,a}\, t_{y,a}, \sigma^2_{\text{obs}}\right),}
where \code{sd_obs_modmat \%*\% log_sd_obs} controls observation SD (by block),
and \code{q_modmat \%*\% log_q} controls age- (or block-) specific catchability.
}

When \code{simulate = TRUE}, the function:
\enumerate{
\item draws \code{log_r} (RW), optional \code{log_n} (cohort residual field),
optional \code{log_m} (M deviations), and \code{log_f} (F deviations) from
their respective process models via \code{rprocess_2d()};
\item regenerates predictions and draws \code{log_obs} from the observation
model;
\item returns the simulated objects.
Missing observations are preserved (filled and then reset to \code{NA}).
}

\code{REPORT()} and \code{ADREPORT()} calls inside the function make derived
quantities (e.g., \code{N}, \code{F}, \code{M}, \code{Z}, \code{ssb}, \code{log_ssb}) available through
\code{obj$report()} / \code{sdreport()} when used via \pkg{RTMB}.
}
\section{Dependencies and captured data}{

The function expects a \code{dat} list in its lexical scope (created by
\code{\link[=make_dat]{make_dat()}}) containing data matrices/vectors and model matrices
(\code{SW}, \code{MO}, \code{obs_map}, \code{sd_obs_modmat}, \code{q_modmat}, \code{F_modmat},
\code{M_modmat}, settings lists, etc.). It also relies on helper functions
\code{\link[=dprocess_2d]{dprocess_2d()}} and \code{\link[=rprocess_2d]{rprocess_2d()}} for process penalties and simulation.
}

\section{Notes on identifiability}{

\itemize{
\item For \code{F_settings$process = "rw"} the mean surface is typically set to
\code{mu_form = NULL} (non-stationary field) to avoid confounding with a
free intercept/trend.
\item For AR(1) penalties, \verb{logit_phi_*} is transformed with \code{plogis()};
keep \eqn{\phi} away from \eqn{\pm 1} for numerical stability.
}
}

\examples{
\dontrun{
# Typical usage through RTMB::MakeADFun
dat <- make_dat(obs, years = 1983:2024, ages = 2:14)
par <- make_par(dat)
obj <- RTMB::MakeADFun(nll_fun, par, random = c("log_f","log_r"), silent = TRUE)
opt <- nlminb(obj$par, obj$fn, obj$gr)
rep <- obj$report()

# Simulate from fitted parameters
p_hat <- as.list(sdreport(obj), "Estimate")
sims  <- nll_fun(p_hat, simulate = TRUE)
}

}
\seealso{
\code{\link[=make_dat]{make_dat()}}, \code{\link[=make_par]{make_par()}}, \code{\link[=fit_tam]{fit_tam()}}, \code{\link[=sim_tam]{sim_tam()}},
\code{\link[=dprocess_2d]{dprocess_2d()}}, \code{\link[=rprocess_2d]{rprocess_2d()}}
}
